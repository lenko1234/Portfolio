<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Design Portfolio | Experiencias Digitales Premium</title>

    <!-- Hreflang tags for multilingual SEO -->
    <link rel="alternate" hreflang="es" href="https://noxsites.com/es/" />
    <link rel="alternate" hreflang="en" href="https://noxsites.com/" />
    <link rel="alternate" hreflang="x-default" href="https://noxsites.com/" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link
        href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;500&family=Plus+Jakarta+Sans:wght@800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --emerald: #10b981;
            --emerald-dim: rgba(16, 185, 129, 0.1);
            --emerald-bright: #34d399;
        }

        /* === HERO SECTION STYLES === */
        #hero-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.8s ease;
        }

        #hero-ui {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 15;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.8s ease;
        }

        .hero-content {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 1;
            transition: opacity 0.8s ease;
            pointer-events: none;
        }

        .hero-content * {
            pointer-events: auto;
        }

        /* === MAIN BODY STYLES === */
        html,
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
            height: 4000vh;
            /* Scroll depth for timeline scrubbing */
            scrollbar-width: none;
            -ms-overflow-style: none;
            overflow-x: hidden;
            color: #fff;
            cursor: crosshair;
            /* Bloqueo de selección de texto para no romper los boids */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
        }

        body::-webkit-scrollbar {
            display: none;
        }

        .viewport {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #020804 0%, #000 100%);
            overflow: hidden;
        }

        /* SVG Narrative Layer */
        #svg-layer {
            position: absolute;
            inset: 0;
            z-index: 5;
            pointer-events: none;
        }

        .thread-main {
            fill: none;
            stroke: var(--emerald);
            stroke-width: 1.5;
            stroke-linecap: square;
            stroke-linejoin: miter;
            filter: drop-shadow(0 0 5px rgba(16, 185, 129, 0.4));
        }

        .thread-branch {
            fill: none;
            stroke: var(--emerald);
            stroke-width: 1;
            stroke-dasharray: 4 4;
            opacity: 0.4;
        }

        .head-dot {
            fill: #fff;
            filter: drop-shadow(0 0 10px var(--emerald-bright));
        }

        /* Content Stage */
        #stage {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .node-fragment {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: none;
            will-change: opacity, transform, letter-spacing, filter;
            max-width: 90vw;
            /* Aumentado para textos en español */
            z-index: 100;
            /* Siempre por encima de las imágenes */
        }

        .primary-text {
            font-family: 'Plus Jakarta Sans', sans-serif;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: -0.05em;
            line-height: 0.85;
            color: #fff;
            text-align: center;
        }

        .data-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 10px;
            color: var(--emerald);
            letter-spacing: 0.4em;
            opacity: 0.6;
            margin-top: 15px;
            display: block;
            text-align: center;
        }

        .cursor {
            display: inline-block;
            width: 8px;
            height: 1em;
            background: var(--emerald);
            margin-left: 2px;
            vertical-align: middle;
            animation: blink 0.8s infinite;
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }

        .vignette {
            position: absolute;
            inset: 0;
            background: radial-gradient(circle, transparent 40%, rgba(0, 0, 0, 0.8) 100%);
            z-index: 30;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .vignette {
                background: radial-gradient(circle, transparent 60%, rgba(0, 0, 0, 0.7) 100%);
            }
        }

        /* UI elements */
        .system-marker {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 9px;
            color: var(--emerald);
            opacity: 0.3;
            letter-spacing: 2px;
        }

        /* Project Images */
        .project-image-container {
            position: absolute;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.8s ease;
            transform: translate(-50%, -50%);
            z-index: 50;
            /* Por debajo del texto */
        }

        .project-image-link {
            display: block;
            position: relative;
            overflow: hidden;
            border: 2px solid var(--emerald);
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3),
                0 0 40px rgba(16, 185, 129, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            background: transparent;
            /* Eliminado el fondo negro que oscurecía */
        }

        .project-image-link:hover {
            border-color: var(--emerald-bright);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.5),
                0 0 60px rgba(16, 185, 129, 0.2);
            transform: scale(1.02);
        }

        .project-image {
            display: block;
            width: 100%;
            min-width: 450px;
            max-width: 500px;
            height: auto;
            opacity: 1;
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        @media (max-width: 768px) {
            .project-image {
                min-width: 0;
                width: 85vw;
                max-width: 400px;
            }
        }

        .project-image-link:hover .project-image {
            opacity: 1;
            transform: scale(1.05);
        }

        .project-overlay {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg,
                    rgba(16, 185, 129, 0.1) 0%,
                    transparent 50%);
            pointer-events: none;
        }

        /* === CTA SECTION STYLES === */

        /* Section Header */
        .section-header {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            color: var(--emerald);
            opacity: 0;
            letter-spacing: 0.4em;
            text-align: center;
            z-index: 15;
            pointer-events: none;
        }

        /* CTA Container */
        #cta-section {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            z-index: 35;
            background: radial-gradient(circle at center, #020804 0%, #000 100%);
        }

        #cta-section.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* Matrix Grid Background */
        .grid-line-h {
            position: absolute;
            width: 100%;
            height: 1px;
            background: rgba(16, 185, 129, 0.5);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.4);
        }

        .grid-line-v {
            position: absolute;
            height: 100%;
            width: 1px;
            background: rgba(16, 185, 129, 0.5);
            box-shadow: 0 0 12px rgba(16, 185, 129, 0.4);
        }

        /* Bulb Light & Shine Effects */
        .bulb-text {
            position: relative;
            text-shadow: 0 0 20px rgba(16, 185, 129, 0.9), 0 0 40px rgba(16, 185, 129, 0.4);
            animation: flicker 4s infinite;
            display: inline-block;
        }

        .shine-overlay {
            position: absolute;
            inset: 0;
            color: white;
            opacity: 0;
            filter: blur(6px);
            pointer-events: none;
            white-space: nowrap;
            animation: shine 5s ease-in-out infinite;
        }

        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.15);
            opacity: 0.2;
            pointer-events: none;
            animation: scanline 4s linear infinite;
        }

        /* Terminal Buttons */
        .terminal-btn {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(16, 185, 129, 0.4);
            position: relative;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(4px);
            padding: 1.25rem 2rem;
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.3em;
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--emerald);
            cursor: pointer;
        }

        .terminal-btn:hover {
            background: rgba(16, 185, 129, 0.15);
            border-color: var(--emerald);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
        }

        .terminal-btn:active {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 0 30px rgba(16, 185, 129, 0.4);
            background: rgba(16, 185, 129, 0.25);
        }

        .terminal-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .terminal-btn:hover::before {
            transform: translateX(100%);
        }

        .glow-dot {
            width: 8px;
            height: 8px;
            background-color: var(--emerald);
            border-radius: 50%;
            box-shadow: 0 0 12px var(--emerald);
            animation: pulse 2s infinite;
        }

        /* Animations */
        @keyframes flicker {

            0%,
            18%,
            22%,
            62%,
            64%,
            66%,
            70%,
            100% {
                opacity: 1;
            }

            20%,
            63%,
            65%,
            69% {
                opacity: 0.5;
                filter: brightness(0.8);
            }
        }

        @keyframes shine {

            0%,
            10% {
                opacity: 0;
                transform: translateX(-10%) skewX(-20deg);
            }

            20% {
                opacity: 0.6;
                transform: translateX(0%) skewX(-20deg);
            }

            30%,
            100% {
                opacity: 0;
                transform: translateX(10%) skewX(-20deg);
            }
        }

        @keyframes scanline {
            0% {
                top: -10%;
            }

            100% {
                top: 110%;
            }
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
                box-shadow: 0 0 12px var(--emerald);
            }

            50% {
                transform: scale(1.3);
                opacity: 0.6;
                box-shadow: 0 0 20px var(--emerald);
            }
        }

        @keyframes simple-pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.4;
            }
        }
    </style>
</head>

<body>

    <!-- HERO SECTION -->
    <div id="hero-canvas"></div>

    <div id="hero-ui">
        <h1 style="font-size: 0.875rem; letter-spacing: 0.4em; font-weight: bold; color: var(--emerald);">
            EMERALD_SWARM_v2.5</h1>
        <div
            style="font-size: 11px; opacity: 0.7; margin-top: 0.5rem; line-height: 1.6; font-family: 'JetBrains Mono', monospace;">
            POPULATION: 4500 UNITS<br>
            CORE_STATUS: <span id="core-status" style="color: var(--emerald-bright);">IDLE</span><br>
            SYS_SYNC: <span id="hero-scroll-offset">0000</span>
        </div>
    </div>

    <div class="hero-content" id="hero-content">
        <div style="text-align: center;">
            <p
                style="font-size: 10px; letter-spacing: 0.6em; opacity: 0.4; margin-bottom: 1.5rem; animation: simple-pulse 2s infinite; font-family: 'JetBrains Mono', monospace;">
                INITIATING_SYSTEM_BOOT</p>
            <h2 class="bulb-text"
                style="font-size: clamp(2.5rem, 8vw, 6rem); font-weight: 900; letter-spacing: -0.05em; margin-bottom: 2rem; font-family: 'Plus Jakarta Sans', sans-serif;">
                &gt; DIGITAL<br>ARCHITECT
            </h2>
            <p style="font-size: 11px; letter-spacing: 0.3em; opacity: 0.6; font-family: 'JetBrains Mono', monospace;">
                DESPLÁZATE PARA EXPLORAR PROYECTOS</p>
        </div>
    </div>

    <div class="system-marker">DISEÑO_WEB: EXPERIENCIAS_PREMIUM // ESTADO: DISPONIBLE</div>

    <div class="viewport">
        <div class="vignette"></div>

        <svg id="svg-layer">
            <path id="main-path" class="thread-main" d=""></path>
            <path id="branch-a" class="thread-branch" d=""></path>
            <path id="branch-b" class="thread-branch" d=""></path>
            <circle id="head" class="head-dot" r="3.5"></circle>
        </svg>

        <div id="stage"></div>

        <!-- PROJECTS Section Header -->
        <div class="section-header" id="projects-header">
            // SECCIÓN: PROYECTOS
        </div>

        <!-- CTA SECTION -->
        <div id="cta-section">
            <!-- Matrix Grid Background -->
            <div style="position: absolute; inset: 0; opacity: 0.25; pointer-events: none; z-index: 0;">
                <div id="h-lines" style="position: absolute; inset: -100px; height: calc(100% + 200px);"></div>
                <div id="v-lines" style="position: absolute; inset: -100px; width: calc(100% + 200px);"></div>
                <div
                    style="position: absolute; inset: 0; background: radial-gradient(circle at 50% 50%, transparent 0%, black 85%);">
                </div>
            </div>

            <!-- Status Header -->
            <div
                style="margin-bottom: 2.5rem; text-align: center; opacity: 0.9; text-transform: uppercase; letter-spacing: 0.3em; font-size: 10px; font-family: 'JetBrains Mono', monospace;">
                <div
                    style="display: flex; align-items: center; justify-content: center; gap: 0.75rem; margin-bottom: 1.5rem;">
                    <div class="glow-dot"></div>
                    <p>ESTADO: <span
                            style="color: var(--emerald-bright); font-weight: bold;">DISPONIBLE_PARA_PROYECTOS</span>
                    </p>
                </div>
                <div
                    style="display: flex; flex-wrap: wrap; justify-center; gap: 2rem; color: rgba(16, 185, 129, 0.5); font-weight: bold;">
                    <span>// TIEMPO_RESPUESTA: <24H< /span>
                            <span>// ZONA_HORARIA: GMT-3</span>
                            <span>// SISTEMA: ESTABLE</span>
                </div>
            </div>

            <!-- Bulb Light Header -->
            <div style="position: relative; margin-bottom: 4rem; text-align: center; padding: 0 1rem;">
                <!-- Soft Glow Background -->
                <div
                    style="position: absolute; inset: -3rem; background: rgba(16, 185, 129, 0.1); filter: blur(80px); opacity: 0.4; transition: opacity 1s;">
                </div>

                <h1
                    style="position: relative; font-size: clamp(2rem, 7vw, 5rem); font-weight: 900; letter-spacing: -0.05em; line-height: 1; user-select: none; font-family: 'Plus Jakarta Sans', sans-serif;">
                    <!-- Shine Layer -->
                    <span class="shine-overlay" aria-hidden="true">> ¿LISTO PARA COMENZAR TU PROYECTO?</span>

                    <!-- Main Flickering Text -->
                    <span class="bulb-text">
                        > ¿LISTO PARA COMENZAR<br style="display: block;">TU PROYECTO?
                    </span>

                    <!-- Moving Scanline -->
                    <div class="scanline"></div>
                </h1>
            </div>

            <!-- Terminal Buttons -->
            <div
                style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; width: 100%; max-width: 56rem; padding: 0 1.5rem; pointer-events: auto;">
                <button class="terminal-btn">
                    [ENVIAR_EMAIL]
                </button>
                <button class="terminal-btn">
                    [MÁS_INFO]
                </button>
                <button class="terminal-btn">
                    [AGENDAR_LLAMADA]
                </button>
            </div>

            <!-- System Footer -->
            <div
                style="position: absolute; bottom: 2.5rem; width: 100%; display: flex; justify-content: space-between; padding: 0 3rem; font-size: 9px; opacity: 0.4; text-transform: uppercase; letter-spacing: 0.4em; font-weight: bold; font-family: 'JetBrains Mono', monospace;">
                <div>SYS_OS: MATRIX_CORE_v4</div>
                <div id="scroll-display">SYNC_OFFSET: [0000]</div>
                <div style="display: none;" class="md:block">LOC: 34.6037° S, 58.3816° W</div>
            </div>
        </div>
    </div>

    <script>
        const stage = document.getElementById('stage');
        const mainPath = document.getElementById('main-path');
        const branchA = document.getElementById('branch-a');
        const branchB = document.getElementById('branch-b');
        const head = document.getElementById('head');
        const svgLayer = document.getElementById('svg-layer');

        /**
         * WEB DESIGN SERVICES TIMELINE
         * Coordinates kept in safe-zone (20% to 80%) to fit the screen perfectly.
         * behavior: 1 (Scale), 2 (Spacing), 3 (Blur), 4 (Skew)
         * image: optional project screenshot
         * url: optional project link
         */
        const nodes = [
            { id: 1, pos: [50, 25], text: "LANDING\nPAGES", label: "CONVERSIÓN_MÁXIMA", life: [6, 18], behavior: 1, image: "assets/EsquinaJardin.png", url: "#" },
            { id: 2, pos: [70, 45], text: "PLATAFORMAS\nE-COMMERCE", label: "VENTAS_24/7", life: [18, 28], behavior: 2, hasBranch: true, image: "assets/ElectroAguirre.png", url: "#" },
            { id: 3, pos: [25, 70], text: "APLICACIONES\nWEB", label: "EXPERIENCIAS_INTERACTIVAS", life: [28, 42], behavior: 3, image: "assets/FGHerreria.png", url: "#" },
            { id: 4, pos: [70, 30], text: "SITIOS\nCORPORATIVOS", label: "PRESENCIA_PREMIUM", life: [44, 56], behavior: 4, hasBranch: true, image: "assets/Panzo.png", url: "#" },
            { id: 5, pos: [50, 60], text: "DISEÑO\nPORTFOLIO", label: "IMPACTO_VISUAL", life: [58, 70], behavior: 1 }
        ];

        // Create Text Elements (without images)
        const textElements = nodes.map(n => {
            const div = document.createElement('div');
            div.className = 'node-fragment';
            div.style.left = `${n.pos[0]}%`;
            div.style.top = `${n.pos[1]}%`;

            div.innerHTML = `
                <div class="primary-text" style="font-size: 8vw;"><span class="content"></span><span class="cursor"></span></div>
                <span class="data-label"></span>
            `;
            stage.appendChild(div);
            return { ...n, el: div, content: div.querySelector('.content'), labelEl: div.querySelector('.data-label'), cursor: div.querySelector('.cursor') };
        });

        // Create Image Elements separately with random positions
        const imageElements = nodes.filter(n => n.image && n.url).map(n => {
            const imageDiv = document.createElement('div');
            imageDiv.className = 'project-image-container';

            const isMobile = window.innerWidth < 768;

            // Random position logic: centered on X for mobile, random on desktop
            let randomX, randomY;
            const topMargin = 30; // Clear top 30% for the header

            if (isMobile) {
                // Mobile: Strictly centered horizontal with a tiny jitter (45-55%)
                randomX = 50 + (Math.random() - 0.5) * 10;
                // Mobile: Random vertical but respecting topMargin (30% to 85%)
                randomY = topMargin + Math.random() * (85 - topMargin);

                // Vertical safety: if too close to the text, push it far away
                const textY = n.pos[1];
                if (Math.abs(randomY - textY) < 30) {
                    // Only push up if it stays below the topMargin
                    randomY = textY > (topMargin + 15) ? (topMargin + 5) : 85;
                }
            } else {
                // Desktop logic: More freedom but avoid edges (20-80% for safety)
                const marginX = 20; // Aumentado de 15 a 20 para más seguridad
                const marginY_bottom = 20;
                randomX = marginX + Math.random() * (100 - marginX * 2);
                randomY = topMargin + Math.random() * (100 - topMargin - marginY_bottom);

                // Diagonal safety distance logic for desktop
                const textX = n.pos[0];
                const textY = n.pos[1];
                let distance = Math.sqrt(Math.pow(randomX - textX, 2) + Math.pow(randomY - textY, 2));
                if (distance < 45) {
                    randomX = textX > 50 ? marginX : (100 - marginX);
                    randomY = textY > 50 ? topMargin : (100 - marginY_bottom);
                }
            }

            imageDiv.style.left = `${randomX}%`;
            imageDiv.style.top = `${randomY}%`;

            imageDiv.innerHTML = `
                <a href="${n.url}" class="project-image-link" target="_blank" rel="noopener noreferrer">
                    <img src="${n.image}" alt="${n.text.replace('\n', ' ')}" class="project-image">
                    <div class="project-overlay"></div>
                </a>
            `;
            stage.appendChild(imageDiv);
            return { ...n, imageEl: imageDiv };
        });

        // Robust Orthogonal path logic: strictly horizontal then vertical
        function getOrthogonal(x1, y1, x2, y2, p) {
            let midX, midY;
            if (p <= 0.5) {
                midX = x1 + (x2 - x1) * (p * 2);
                midY = y1;
            } else {
                midX = x2;
                midY = y1 + (y2 - y1) * ((p - 0.5) * 2);
            }
            return { x: midX, y: midY, isCorner: p > 0.5 };
        }

        function update() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            svgLayer.setAttribute('width', w);
            svgLayer.setAttribute('height', h);

            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            const scrollMax = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrollY / scrollMax) * 100;

            let dMain = "";
            let dBA = "";
            let dBB = "";
            let hX, hY;

            const tailLength = 15;
            const tStart = Math.max(0, progress - tailLength);

            // DRAW MAIN NARRATIVE THREAD
            for (let i = 0; i < nodes.length - 1; i++) {
                const n1 = nodes[i], n2 = nodes[i + 1];
                const sStart = Math.max(tStart, n1.life[0]);
                const sEnd = Math.min(progress, n2.life[0]);

                if (sStart < sEnd) {
                    const p1 = (sStart - n1.life[0]) / (n2.life[0] - n1.life[0]);
                    const p2 = (sEnd - n1.life[0]) / (n2.life[0] - n1.life[0]);

                    const x1 = n1.pos[0] * w / 100, y1 = n1.pos[1] * h / 100;
                    const x2 = n2.pos[0] * w / 100, y2 = n2.pos[1] * h / 100;

                    const pA = getOrthogonal(x1, y1, x2, y2, p1);
                    const pB = getOrthogonal(x1, y1, x2, y2, p2);

                    if (dMain === "") dMain = `M ${pA.x} ${pA.y}`;
                    if (!pA.isCorner && pB.isCorner) dMain += ` L ${x2} ${y1}`;
                    dMain += ` L ${pB.x} ${pB.y}`;

                    if (sEnd === progress) { hX = pB.x; hY = pB.y; }

                    // BRANCHING CIRCUITRY (90-deg branching)
                    if (n1.hasBranch && progress > n1.life[0]) {
                        const bProg = Math.min((progress - n1.life[0]) / 8, 1);
                        const bDist = Math.min(w * 0.1, 100);

                        // Branch A (sideways then down)
                        const bA_End = getOrthogonal(x1, y1, x1 - bDist, y1 + bDist, bProg);
                        dBA += `M ${x1} ${y1} L ${x1 - bDist} ${y1} L ${x1 - bDist} ${bA_End.y}`;

                        // Branch B (sideways then up)
                        const bB_End = getOrthogonal(x1, y1, x1 + bDist, y1 - bDist, bProg);
                        dBB += `M ${x1} ${y1} L ${x1 + bDist} ${y1} L ${x1 + bDist} ${bB_End.y}`;
                    }
                }
            }

            mainPath.setAttribute('d', dMain);
            branchA.setAttribute('d', dBA);
            branchB.setAttribute('d', dBB);

            if (hX !== undefined) {
                head.setAttribute('cx', hX); head.setAttribute('cy', hY);
                head.style.opacity = 1;
            } else { head.style.opacity = 0; }

            // DISCOVER TEXT
            textElements.forEach(node => {
                const isActive = progress >= node.life[0] && progress <= node.life[1];
                if (isActive) {
                    node.el.style.display = 'block';
                    const local = (progress - node.life[0]) / (node.life[1] - node.life[0]);

                    // Typing Animation (Keyboard)
                    const typeP = Math.min(local / 0.4, 1);
                    const chars = Math.floor(node.text.length * typeP);
                    node.content.innerText = node.text.substring(0, chars);
                    node.cursor.style.display = typeP < 1 ? 'inline-block' : 'none';
                    node.labelEl.innerText = typeP > 0.8 ? node.label : "";

                    // Opacity Transition
                    let op = 1;
                    if (local < 0.2) op = local / 0.2;
                    else if (local > 0.8) op = 1 - (local - 0.8) / 0.2;
                    node.el.style.opacity = op;

                    // Heterogeneous Patterns (No Vertical, No Rotation)
                    const transform = [];
                    node.el.style.letterSpacing = "0em";
                    node.el.style.filter = "none";

                    if (node.behavior === 1) { // Pulsing scale
                        transform.push(`scale(${0.8 + local * 0.3})`);
                    } else if (node.behavior === 2) { // Tracking reveal
                        node.el.style.letterSpacing = `${(1 - local) * 0.7}em`;
                    } else if (node.behavior === 3) { // Blur discovery
                        node.el.style.filter = `blur(${(1 - local) * 12}px)`;
                    } else if (node.behavior === 4) { // Skew
                        transform.push(`skewX(${(1 - local) * 15}deg)`);
                    }

                    node.el.style.transform = `translate(-50%, -50%) ${transform.join(' ')}`;
                } else {
                    node.el.style.display = 'none';
                }
            });

            // Animate Images independently
            imageElements.forEach(imgNode => {
                const isActive = progress >= imgNode.life[0] && progress <= imgNode.life[1];
                if (isActive) {
                    const local = (progress - imgNode.life[0]) / (imgNode.life[1] - imgNode.life[0]);
                    const typeP = Math.min(local / 0.4, 1);

                    // Image appearance speed boost
                    const imageDelay = 0.25; // Keep starting at 25% of node life
                    const animationDuration = 0.1; // FAST! Only 10% of node life to reach full opacity
                    const imageP = Math.max(0, Math.min(1, (local - imageDelay) / animationDuration));
                    imgNode.imageEl.style.opacity = imageP;
                } else {
                    imgNode.imageEl.style.opacity = 0;
                }
            });
        }

        window.addEventListener('scroll', update);
        window.addEventListener('resize', update);
        update(); // Initial run

        // Subtle Mouse Depth
        window.addEventListener('mousemove', (e) => {
            const x = (e.clientX / window.innerWidth - 0.5) * 10;
            const y = (e.clientY / window.innerHeight - 0.5) * 10;
            svgLayer.style.transform = `translate(${x}px, ${y}px)`;
            stage.style.transform = `translate(${x / 2}px, ${y / 2}px)`;
        });

        // === CTA SECTION CONTROL ===
        const ctaSection = document.getElementById('cta-section');
        const projectsHeader = document.getElementById('projects-header');
        const hLinesContainer = document.getElementById('h-lines');
        const vLinesContainer = document.getElementById('v-lines');
        const scrollDisplay = document.getElementById('scroll-display');

        // Create Matrix Grid Lines
        const hLineCount = 30;
        const vLineCount = 30;

        for (let i = 0; i < hLineCount; i++) {
            const hLine = document.createElement('div');
            hLine.className = 'grid-line-h';
            hLine.style.top = `${(100 / hLineCount) * i}%`;
            hLinesContainer.appendChild(hLine);
        }

        for (let i = 0; i < vLineCount; i++) {
            const vLine = document.createElement('div');
            vLine.className = 'grid-line-v';
            vLine.style.left = `${(100 / vLineCount) * i}%`;
            vLinesContainer.appendChild(vLine);
        }

        // Update CTA section visibility and animations
        function updateCTA() {
            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            const scrollMax = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrollY / scrollMax) * 100;

            console.log('Scroll Progress:', progress.toFixed(2) + '%');

            // Show PROJECTS header during projects timeline (6-70%)
            if (progress >= 6 && progress < 70) {
                const headerProgress = (progress - 6) / 5; // Fade in over 5% (6-11%)
                projectsHeader.style.opacity = Math.min(1, headerProgress);
            } else {
                projectsHeader.style.opacity = 0;
            }

            // Show CTA section at 75%+ (gap after projects end at 70%)
            if (progress >= 75) {
                ctaSection.classList.add('active');
                const ctaProgress = (progress - 75) / 25; // 0 to 1 in the 75-100% range
                ctaSection.style.opacity = Math.min(1, ctaProgress * 2); // Fade in quickly
                console.log('CTA Active - Progress:', progress, 'Opacity:', ctaSection.style.opacity);
            } else {
                ctaSection.classList.remove('active');
                ctaSection.style.opacity = 0;
            }

            // Matrix grid parallax animation
            const hOffset = (scrollY * 0.4) % 100;
            const vOffset = (scrollY * 0.15) % 100;
            hLinesContainer.style.transform = `translateY(${hOffset}px)`;
            vLinesContainer.style.transform = `translateX(${vOffset}px)`;

            // Update scroll offset display
            const paddedScroll = Math.floor(scrollY).toString().padStart(4, '0');
            scrollDisplay.innerText = `SYNC_OFFSET: [${paddedScroll}]`;
        }

        // Wrap the original update function to include CTA updates
        const originalUpdate = update;
        update = function () {
            originalUpdate();
            updateCTA();
        };

        // Re-attach scroll listeners with the new wrapped update function
        window.removeEventListener('scroll', originalUpdate);
        window.addEventListener('scroll', update);
        window.addEventListener('resize', update);

        updateCTA(); // Initial run

        // === HERO BOIDS SECTION ===
        const COUNT_ACTIVE = 1500;
        const COUNT_INDEP = 3000;
        const TOTAL_COUNT = COUNT_ACTIVE + COUNT_INDEP;
        const BOUNDS = 400;
        const MAX_SPEED = 2.4;
        const ATTRACTION_FORCE = 0.28;

        let scene, camera, renderer, activeMesh, indepMesh;
        const positions = new Float32Array(TOTAL_COUNT * 3);
        const velocities = new Float32Array(TOTAL_COUNT * 3);

        let isAttracting = false;
        let attractionPoint = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const mouse2 = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const dummy = new THREE.Object3D();
        const v1 = new THREE.Vector3(), v2 = new THREE.Vector3(), v3 = new THREE.Vector3();

        function initBoids() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('hero-canvas').appendChild(renderer.domElement);

            const sharedGeo = new THREE.ConeGeometry(1.2, 5.5, 3);
            sharedGeo.rotateX(Math.PI / 2);
            const sharedMat = new THREE.MeshPhongMaterial({
                color: 0x10b981,
                emissive: 0x064e3b,
                shininess: 100,
                transparent: true,
                opacity: 0.85
            });

            activeMesh = new THREE.InstancedMesh(sharedGeo, sharedMat, COUNT_ACTIVE);
            indepMesh = new THREE.InstancedMesh(sharedGeo, sharedMat, COUNT_INDEP);
            scene.add(activeMesh, indepMesh);

            scene.add(new THREE.AmbientLight(0x0a220a, 2.5));
            const pLight = new THREE.PointLight(0x10b981, 2, 1500);
            pLight.position.set(0, 500, 400);
            scene.add(pLight);

            for (let i = 0; i < TOTAL_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * BOUNDS * 5;
                positions[i * 3 + 1] = (Math.random() - 0.5) * BOUNDS * 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS * 5;
                velocities[i * 3] = (Math.random() - 0.5) * 5;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 5;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 5;
            }

            window.addEventListener('pointerdown', () => {
                isAttracting = true;
                document.getElementById('core-status').innerText = 'CORE_REVEALED';
                document.getElementById('core-status').style.color = '#fff';
            });
            window.addEventListener('pointerup', () => {
                isAttracting = false;
                document.getElementById('core-status').innerText = 'IDLE';
                document.getElementById('core-status').style.color = '#10b981';
            });
            window.addEventListener('pointermove', e => {
                mouse2.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse2.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            animateBoids();
        }

        function animateBoids() {
            requestAnimationFrame(animateBoids);

            raycaster.setFromCamera(mouse2, camera);
            raycaster.ray.intersectPlane(plane, attractionPoint);

            for (let i = 0; i < TOTAL_COUNT; i++) {
                const isActive = i < COUNT_ACTIVE;
                const accel = v3.set(0, 0, 0);

                if (isActive && isAttracting) {
                    const seek = attractionPoint.clone().sub(v2.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]));
                    seek.setLength(MAX_SPEED).sub(v1.set(velocities[i * 3], velocities[i * 3 + 1], velocities[i * 3 + 2]));
                    accel.add(seek.multiplyScalar(ATTRACTION_FORCE));
                }

                velocities[i * 3] += accel.x; velocities[i * 3 + 1] += accel.y; velocities[i * 3 + 2] += accel.z;
                v1.set(velocities[i * 3], velocities[i * 3 + 1], velocities[i * 3 + 2]).clampLength(0, MAX_SPEED);
                velocities[i * 3] = v1.x; velocities[i * 3 + 1] = v1.y; velocities[i * 3 + 2] = v1.z;

                positions[i * 3] += velocities[i * 3];
                positions[i * 3 + 1] += velocities[i * 3 + 1];
                positions[i * 3 + 2] += velocities[i * 3 + 2];

                const l = BOUNDS * 2.8;
                if (Math.abs(positions[i * 3]) > l) positions[i * 3] *= -0.98;
                if (Math.abs(positions[i * 3 + 1]) > l) positions[i * 3 + 1] *= -0.98;
                if (Math.abs(positions[i * 3 + 2]) > l) positions[i * 3 + 2] *= -0.98;

                dummy.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                dummy.lookAt(positions[i * 3] + velocities[i * 3], positions[i * 3 + 1] + velocities[i * 3 + 1], positions[i * 3 + 2] + velocities[i * 3 + 2]);
                dummy.updateMatrix();

                const mesh = isActive ? activeMesh : indepMesh;
                mesh.setMatrixAt(isActive ? i : i - COUNT_ACTIVE, dummy.matrix);
            }
            activeMesh.instanceMatrix.needsUpdate = true;
            indepMesh.instanceMatrix.needsUpdate = true;

            // Removed scene rotation to fix attraction point drift
            renderer.render(scene, camera);
        }

        // Hero fade out logic
        const heroCanvas = document.getElementById('hero-canvas');
        const heroUI = document.getElementById('hero-ui');
        const heroContent = document.getElementById('hero-content');
        const heroScrollOffset = document.getElementById('hero-scroll-offset');

        const originalUpdateCTA = updateCTA;
        updateCTA = function () {
            originalUpdateCTA();

            const scrollY = window.pageYOffset || document.documentElement.scrollTop;
            const scrollMax = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrollY / scrollMax) * 100;

            // --- Lógica Persistente de Boids ---
            if (progress < 6) {
                // Transición del Hero al modo "proyectos" (0% a 6%)
                const fadeFactor = Math.max(0.25, 1 - (progress / 4));
                heroCanvas.style.opacity = fadeFactor;

                // Reducir población gradualmente (de 4500 a 500)
                if (activeMesh && indepMesh) {
                    activeMesh.count = Math.floor(1500 * (fadeFactor));
                    indepMesh.count = Math.floor(3000 * (fadeFactor));
                }
            } else if (progress < 70) {
                // Durante Proyectos: Opacidad sutil y solo 500 boids
                heroCanvas.style.opacity = "0.25";
                if (activeMesh && indepMesh) {
                    activeMesh.count = 500;
                    indepMesh.count = 0;
                }
            } else {
                // Desvanecer completamente para el CTA (70% a 75%)
                const finalFade = Math.max(0, 1 - (progress - 70) / 5);
                heroCanvas.style.opacity = 0.25 * finalFade;
                if (activeMesh) activeMesh.count = Math.floor(500 * finalFade);
            }

            // Elementos UI del Hero siempre desaparecen rápido
            const uiFade = Math.max(0, 1 - (progress / 3));
            heroUI.style.opacity = uiFade;
            heroContent.style.opacity = uiFade;

            heroScrollOffset.innerText = Math.floor(scrollY).toString().padStart(4, '0');
        };

        // Initialize hero
        if (typeof THREE !== 'undefined') {
            initBoids();
        }

        // Resize handler for hero
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>

</html>