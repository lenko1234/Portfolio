<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emerald Swarm | System Core</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --emerald-glow: #10b981;
        }

        body {
            margin: 0;
            background-color: #000;
            color: var(--emerald-glow);
            font-family: 'Courier New', Courier, monospace;
            /* Altura extendida para habilitar el scroll y la transición */
            height: 350vh;
            overflow-x: hidden;
            scrollbar-width: thin;
            scrollbar-color: var(--emerald-glow) #000;
        }

        /* --- BACKGROUNDS --- */
        #hero-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: 1;
        }

        #matrix-grid {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            /* Aparece con el scroll */
            z-index: 2;
            transition: opacity 0.8s ease;
        }

        .grid-line-h,
        .grid-line-v {
            position: absolute;
            background: rgba(16, 185, 129, 0.4);
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.3);
        }

        /* --- UI COMPONENTS --- */
        #hero-ui {
            position: fixed;
            top: 30px;
            left: 30px;
            z-index: 10;
            pointer-events: none;
        }

        .bulb-text {
            text-shadow: 0 0 20px var(--emerald-glow), 0 0 40px rgba(16, 185, 129, 0.4);
            animation: flicker 4s infinite;
        }

        @keyframes flicker {

            0%,
            18%,
            22%,
            62%,
            64%,
            70%,
            100% {
                opacity: 1;
            }

            20%,
            63%,
            69% {
                opacity: 0.4;
                filter: brightness(0.8);
            }
        }

        .terminal-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(16, 185, 129, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
        }

        .terminal-btn:hover {
            border-color: var(--emerald-glow);
            background: rgba(16, 185, 129, 0.15);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.2);
            transform: translateY(-2px);
        }

        .terminal-btn::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent, rgba(16, 185, 129, 0.2), transparent);
            transform: translateX(-100%);
            transition: transform 0.6s ease;
        }

        .terminal-btn:hover::after {
            transform: translateX(100%);
        }

        #sections-container {
            position: relative;
            z-index: 20;
        }

        .section {
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            padding: 2rem;
        }

        .section * {
            pointer-events: auto;
        }

        .scanline {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            opacity: 0.1;
            pointer-events: none;
            animation: scanline 4s linear infinite;
        }

        @keyframes scanline {
            0% {
                top: -10%;
            }

            100% {
                top: 110%;
            }
        }
    </style>
</head>

<body>

    <!-- Capa 1: Boids (Tu código adaptado) -->
    <div id="hero-canvas"></div>

    <!-- Capa 2: Matrix Grid (Fondo del CTA) -->
    <div id="matrix-grid">
        <div id="h-lines" style="position: absolute; inset: -100px; height: calc(100% + 200px);"></div>
        <div id="v-lines" style="position: absolute; inset: -100px; width: calc(100% + 200px);"></div>
        <div
            style="position: absolute; inset: 0; background: radial-gradient(circle at 50% 50%, transparent 0%, black 90%);">
        </div>
    </div>

    <!-- UI Superior del Hero -->
    <div id="hero-ui">
        <h1 class="text-sm md:text-lg tracking-[0.4em] font-bold text-emerald-500">EMERALD_SWARM_v2.5</h1>
        <div class="text-[9px] md:text-[11px] opacity-70 mt-2 leading-relaxed font-mono">
            POPULATION: 4500 UNITS<br>
            CORE_STATUS: <span id="core-status" class="text-emerald-400">IDLE</span><br>
            SYS_SYNC: <span id="scroll-offset">0000</span>
        </div>
    </div>

    <!-- Contenido Scrollable -->
    <div id="sections-container">
        <!-- SECCIÓN HERO -->
        <section class="section">
            <div class="text-center">
                <p class="text-[10px] tracking-[0.6em] opacity-40 mb-6 animate-pulse">INITIATING_SYSTEM_BOOT</p>
                <h2 class="text-4xl md:text-7xl lg:text-8xl font-black tracking-tighter mb-8 bulb-text">
                    &gt; DIGITAL<br>ARCHITECT
                </h2>
                <p class="text-[11px] tracking-[0.3em] opacity-60 font-mono">MANTÉN PRESIONADO PARA REVELAR EL NÚCLEO
                </p>
            </div>
        </section>

        <!-- SECCIÓN DE TRANSICIÓN (Espacio vacío para el efecto de scroll) -->
        <section class="section opacity-0"></section>

        <!-- SECCIÓN DE CONTACTO (Matrix) -->
        <section class="section" id="contact-section">
            <div class="mb-12 text-center uppercase tracking-[0.4em] text-[10px] md:text-xs">
                <div class="flex items-center justify-center gap-3 mb-6">
                    <div class="w-2.5 h-2.5 bg-emerald-500 rounded-full animate-pulse shadow-[0_0_12px_#10b981]"></div>
                    <p>STATUS: <span class="text-emerald-400 font-bold">AVAILABLE_FOR_PROJECTS</span></p>
                </div>
                <div class="flex flex-wrap justify-center gap-8 opacity-50 font-bold">
                    <span>// RESP_TIME: <24H< /span>
                            <span>// GMT-3</span>
                </div>
            </div>

            <div class="relative group mb-16 text-center px-4">
                <div class="scanline"></div>
                <h1 class="text-4xl md:text-7xl lg:text-8xl font-black tracking-tighter leading-tight bulb-text">
                    &gt; READY TO START<br>YOUR PROJECT?
                </h1>
            </div>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 w-full max-w-5xl px-8">
                <button class="terminal-btn py-5 px-8 text-[11px] tracking-[0.4em] font-bold">[SEND_EMAIL]</button>
                <button class="terminal-btn py-5 px-8 text-[11px] tracking-[0.4em] font-bold">[VIEW_GITHUB]</button>
                <button class="terminal-btn py-5 px-8 text-[11px] tracking-[0.4em] font-bold">[SCHEDULE_CALL]</button>
            </div>

            <div
                class="absolute bottom-10 w-full flex justify-between px-12 text-[9px] opacity-30 uppercase tracking-[0.5em] font-bold hidden md:flex">
                <div>SYS_OS: MATRIX_CORE</div>
                <div>LOCAL_NODE: AR_BUE_01</div>
                <div>EST_CONNECTION: SECURE</div>
            </div>
        </section>
    </div>

    <script>
        // --- CONFIGURACIÓN BOIDS (Tu lógica integrada) ---
        const COUNT_ACTIVE = 1500;
        const COUNT_INDEP = 3000;
        const TOTAL_COUNT = COUNT_ACTIVE + COUNT_INDEP;
        const BOUNDS = 400;
        const GRID_SIZE = 55;
        const MAX_SPEED = 2.4;
        const ATTRACTION_FORCE = 0.28;

        let scene, camera, renderer, activeMesh, indepMesh;
        const positions = new Float32Array(TOTAL_COUNT * 3);
        const velocities = new Float32Array(TOTAL_COUNT * 3);
        const grid = new Map();

        let isAttracting = false;
        let attractionPoint = new THREE.Vector3();
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
        const dummy = new THREE.Object3D();
        const v1 = new THREE.Vector3(), v2 = new THREE.Vector3(), v3 = new THREE.Vector3();

        function initBoids() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
            camera.position.z = 800;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('hero-canvas').appendChild(renderer.domElement);

            // Geometría y Material unificados Esmeralda
            const sharedGeo = new THREE.ConeGeometry(1.2, 5.5, 3);
            sharedGeo.rotateX(Math.PI / 2);
            const sharedMat = new THREE.MeshPhongMaterial({
                color: 0x10b981,
                emissive: 0x064e3b,
                shininess: 100,
                transparent: true,
                opacity: 0.85
            });

            activeMesh = new THREE.InstancedMesh(sharedGeo, sharedMat, COUNT_ACTIVE);
            indepMesh = new THREE.InstancedMesh(sharedGeo, sharedMat, COUNT_INDEP);
            scene.add(activeMesh, indepMesh);

            scene.add(new THREE.AmbientLight(0x0a220a, 2.5));
            const pLight = new THREE.PointLight(0x10b981, 2, 1500);
            pLight.position.set(0, 500, 400);
            scene.add(pLight);

            // Población Inicial
            for (let i = 0; i < TOTAL_COUNT; i++) {
                positions[i * 3] = (Math.random() - 0.5) * BOUNDS * 5;
                positions[i * 3 + 1] = (Math.random() - 0.5) * BOUNDS * 5;
                positions[i * 3 + 2] = (Math.random() - 0.5) * BOUNDS * 5;
                velocities[i * 3] = (Math.random() - 0.5) * 5;
                velocities[i * 3 + 1] = (Math.random() - 0.5) * 5;
                velocities[i * 3 + 2] = (Math.random() - 0.5) * 5;
            }

            // Eventos de interacción
            window.addEventListener('pointerdown', () => {
                isAttracting = true;
                document.getElementById('core-status').innerText = 'CORE_REVEALED';
                document.getElementById('core-status').style.color = '#fff';
            });
            window.addEventListener('pointerup', () => {
                isAttracting = false;
                document.getElementById('core-status').innerText = 'IDLE';
                document.getElementById('core-status').style.color = '#10b981';
            });
            window.addEventListener('pointermove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);

            raycaster.setFromCamera(mouse, camera);
            raycaster.ray.intersectPlane(plane, attractionPoint);

            for (let i = 0; i < TOTAL_COUNT; i++) {
                const isActive = i < COUNT_ACTIVE;
                const accel = v3.set(0, 0, 0);

                // Solo el grupo activo responde al ratón (tu lógica)
                if (isActive && isAttracting) {
                    const seek = attractionPoint.clone().sub(v2.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]));
                    seek.setLength(MAX_SPEED).sub(v1.set(velocities[i * 3], velocities[i * 3 + 1], velocities[i * 3 + 2]));
                    accel.add(seek.multiplyScalar(ATTRACTION_FORCE));
                }

                // Actualizar Velocidad y Posición
                velocities[i * 3] += accel.x; velocities[i * 3 + 1] += accel.y; velocities[i * 3 + 2] += accel.z;
                v1.set(velocities[i * 3], velocities[i * 3 + 1], velocities[i * 3 + 2]).clampLength(0, MAX_SPEED);
                velocities[i * 3] = v1.x; velocities[i * 3 + 1] = v1.y; velocities[i * 3 + 2] = v1.z;

                positions[i * 3] += velocities[i * 3];
                positions[i * 3 + 1] += velocities[i * 3 + 1];
                positions[i * 3 + 2] += velocities[i * 3 + 2];

                // Rebote en límites
                const l = BOUNDS * 2.8;
                if (Math.abs(positions[i * 3]) > l) positions[i * 3] *= -0.98;
                if (Math.abs(positions[i * 3 + 1]) > l) positions[i * 3 + 1] *= -0.98;
                if (Math.abs(positions[i * 3 + 2]) > l) positions[i * 3 + 2] *= -0.98;

                // Actualizar InstancedMesh
                dummy.position.set(positions[i * 3], positions[i * 3 + 1], positions[i * 3 + 2]);
                dummy.lookAt(positions[i * 3] + velocities[i * 3], positions[i * 3 + 1] + velocities[i * 3 + 1], positions[i * 3 + 2] + velocities[i * 3 + 2]);
                dummy.updateMatrix();

                const mesh = isActive ? activeMesh : indepMesh;
                mesh.setMatrixAt(isActive ? i : i - COUNT_ACTIVE, dummy.matrix);
            }
            activeMesh.instanceMatrix.needsUpdate = true;
            indepMesh.instanceMatrix.needsUpdate = true;

            scene.rotation.y += 0.0005;
            renderer.render(scene, camera);
        }

        // --- LÓGICA DE MATRIX Y SCROLL ---
        function initMatrix() {
            const hLines = document.getElementById('h-lines');
            const vLines = document.getElementById('v-lines');
            const lineCount = 30;

            for (let i = 0; i < lineCount; i++) {
                const hl = document.createElement('div');
                hl.className = 'grid-line-h w-full h-[1px]';
                hl.style.top = `${(100 / lineCount) * i}%`;
                hLines.appendChild(hl);

                const vl = document.createElement('div');
                vl.className = 'grid-line-v h-full w-[1px]';
                vl.style.left = `${(100 / lineCount) * i}%`;
                vLines.appendChild(vl);
            }
        }

        window.addEventListener('scroll', () => {
            const scrollY = window.pageYOffset;
            const viewHeight = window.innerHeight;

            // 1. Desvanecer Boids y Hero UI
            const heroFadeOut = Math.max(0, 1 - (scrollY / (viewHeight * 0.8)));
            document.getElementById('hero-canvas').style.opacity = heroFadeOut;
            document.getElementById('hero-ui').style.opacity = heroFadeOut;

            // 2. Mostrar Matrix Grid en el CTA
            const matrixGrid = document.getElementById('matrix-grid');
            if (scrollY > viewHeight * 1.2) {
                matrixGrid.style.opacity = "0.3";
                const matrixScroll = scrollY - (viewHeight * 1.2);
                document.getElementById('h-lines').style.transform = `translateY(${(matrixScroll * 0.4) % 100}px)`;
                document.getElementById('v-lines').style.transform = `translateX(${(matrixScroll * 0.15) % 100}px)`;
            } else {
                matrixGrid.style.opacity = "0";
            }

            // 3. UI Update
            document.getElementById('scroll-offset').innerText = Math.floor(scrollY).toString().padStart(4, '0');
        });

        // Inicio
        window.onload = () => {
            initBoids();
            initMatrix();
        };

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>